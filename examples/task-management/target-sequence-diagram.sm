# Target Sequence Diagram Design

This document describes what the ideal sequence diagram should look like for the task-management system.

## Actual Flow Analysis

### 1. Task Creation Flow

**User creates a task via Web UI:**
- `TaskStore.createTask()` → `ApiClient.createTask()` → `POST /api/tasks` to API service

**API Service handles task creation:**
- `TaskController.createTask()` → `TaskService.createTask()` → validates, creates task, saves to database
- If task has an assignee: `NotificationService.notifyTaskAssigned()` → `EmailServiceClient.sendTemplateEmail()` → `POST /api/email/send-template` to Email service

**Email Service processes the email:**
- `EmailController.sendTemplateEmail()` → `EmailTemplateService.generateTaskAssignedEmail()` → `EmailSender.queueEmail()` → queues email for SMTP sending

## Target Sequence Diagram

```mermaid
sequenceDiagram
    participant User
    participant WebUI as web-ui-service
    participant API as api-service
    participant Email as email-service
    participant SMTP as SMTP Server

    %% Task Creation Flow
    User->>+WebUI: Create Task (with assignee)
    WebUI->>+API: POST /api/tasks
    API->>API: TaskController.createTask()
    API->>API: TaskService.createTask()
    API->>API: TaskRepository.create()
    API->>API: NotificationService.notifyTaskAssigned()
    API->>+Email: POST /api/email/send-template
    Email->>Email: EmailController.sendTemplateEmail()
    Email->>Email: EmailTemplateService.generateEmail()
    Email->>Email: EmailSender.queueEmail()
    Email-->>-API: {messageId, status: "queued"}
    API-->>-WebUI: {task}
    WebUI-->>-User: Task Created

    %% Async Email Sending
    Email->>+SMTP: Send Email
    SMTP-->>-Email: Email Sent
```

## Key Features to Implement

1. **Show all HTTP calls between services** (cross-service communication)
2. **Show HTTP calls + key internal method calls** (detailed flow within services)
3. **Support multiple scenarios** (create task, update task, assign task, etc.)
4. **Include external services** (SMTP server, databases, etc.)
5. **Show both sync and async flows**

## Implementation Options

### Option 1: Simplified (HTTP calls only)
- Show only cross-service HTTP communication
- Best for understanding service dependencies

### Option 2: Detailed (HTTP + Internal calls)
- Show HTTP calls AND key internal method calls
- Best for understanding complete flow
- Current target design follows this approach

### Option 3: Multiple Scenarios
- Generate separate diagrams for different use cases
- Create task, Update task, Assign task, Delete task

## Current Implementation Results

### Generated Diagram (Latest)

```mermaid
sequenceDiagram
  participant User
  participant api_service as api-service
  participant web_ui_service as web-ui-service
  participant email_service as email-service

  %% Flow: POST `${this.config.baseUrl}/api/email/send-template`
  api_service->>>api_service: createTask()
  api_service->>>api_service: createTask()
  api_service->>>api_service: notifyTaskAssigned()
  api_service->>>api_service: sendTemplateEmail()
  api_service->>+email_service: POST /api/email/send-template`
  email_service-->>-api_service: Response
```

### Comparison: Target vs Generated

#### ✅ What's Working:
1. Detects cross-service HTTP calls (api → email)
2. Shows internal call chain leading to HTTP call
3. Adds User participant automatically (if frontend detected)
4. Data-driven service ordering (no hardcodes)
5. Deduplicates identical flows
6. Extracts clean API paths from template strings
7. Filters out anonymous functions

#### ❌ What's Missing:
1. User interaction arrows (User → web-ui-service)
   - User participant is shown but no arrows from User
   - Need to detect web-ui → api HTTP calls to trigger User interaction

2. Duplicate method names in chain
   - Shows `createTask()` twice (Controller + Service)
   - Should show as `TaskController.createTask()` and `TaskService.createTask()`

3. Missing web-ui → api-service HTTP call
   - Web-ui HTTP calls are too generic (`${baseUrl}${path}`)
   - Cannot match to specific service from URL pattern
   - This is actually correct behavior - those calls are dynamic

4. Missing internal calls within target service
   - Shows api-service internal calls but not email-service internal calls
   - Could trace EmailController.sendTemplateEmail() → EmailSender.queueEmail()

### Next Steps (If Needed):
1. Show full qualified names in call chain (e.g., `TaskService.createTask()` instead of just `createTask()`)
2. Detect web-ui HTTP calls by analyzing ApiClient methods
3. Add target service internal calls (trace from HTTP endpoint handler)
