import { SmFile } from './schemas.js'

/**
 * Converts a SmFile object to markdown format
 *
 * Generates .sm file content according to CONSTITUTION.md Section 4.2 format:
 * - Feature name as # heading
 * - Overview section with markdown content
 * - Requirements as bulleted list
 * - Architecture with mermaid code block
 * - Design decisions as markdown
 * - Integration points as bulleted list
 * - Notes as markdown
 */

export interface WriteResult {
  success: boolean
  content?: string
  error?: string
}

export function writeSmFile(smFile: SmFile): WriteResult {
  try {
    const sections: string[] = []

    // Feature name as main heading
    sections.push(`# ${smFile.name}`)
    sections.push('')

    // Overview section
    if (smFile.overview) {
      sections.push('## Overview')
      sections.push('')
      sections.push(smFile.overview)
      sections.push('')
    }

    // Requirements section
    if (smFile.requirements.length > 0) {
      sections.push('## Requirements')
      sections.push('')
      for (const requirement of smFile.requirements) {
        sections.push(`- ${requirement}`)
      }
      sections.push('')
    }

    // Architecture section
    if (smFile.architecture) {
      sections.push('## Architecture')
      sections.push('')
      sections.push('```mermaid')
      sections.push(smFile.architecture)
      sections.push('```')
      sections.push('')
    }

    // Design decisions section
    if (smFile.designDecisions) {
      sections.push('## Design Decisions')
      sections.push('')
      sections.push(smFile.designDecisions)
      sections.push('')
    }

    // Integration points section
    if (smFile.integrationPoints.length > 0) {
      sections.push('## Integration Points')
      sections.push('')
      for (const point of smFile.integrationPoints) {
        sections.push(`- ${point}`)
      }
      sections.push('')
    }

    // Notes section
    if (smFile.notes) {
      sections.push('## Notes')
      sections.push('')
      sections.push(smFile.notes)
    }

    // Remove trailing empty lines
    while (sections.length > 0 && sections[sections.length - 1] === '') {
      sections.pop()
    }

    const content = sections.join('\n')

    return {
      success: true,
      content
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown writing error'
    }
  }
}

/**
 * Formats a SmFile for display with metadata
 *
 * @param smFile SmFile object
 * @returns Formatted content with metadata comments
 */
export function writeSmFileWithMetadata(smFile: SmFile): WriteResult {
  try {
    const result = writeSmFile(smFile)
    if (!result.success || !result.content) {
      return result
    }

    const metadata = [
      `<!-- Generated by SpecMind -->`,
      `<!-- Type: ${smFile.type} -->`,
      `<!-- Created: ${smFile.createdAt.toISOString()} -->`,
      `<!-- Updated: ${smFile.updatedAt.toISOString()} -->`,
      ''
    ]

    const content = metadata.join('\n') + result.content

    return {
      success: true,
      content
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown writing error'
    }
  }
}

/**
 * Validates that a SmFile can be written without data loss
 *
 * @param smFile SmFile to validate
 * @returns Validation result
 */
export function validateSmFileForWriting(smFile: SmFile): { valid: boolean; issues: string[] } {
  const issues: string[] = []

  if (!smFile.name.trim()) {
    issues.push('Feature name is required')
  }

  if (smFile.architecture && !smFile.architecture.trim()) {
    issues.push('Architecture section is empty but present')
  }

  if (smFile.requirements.some(req => !req.trim())) {
    issues.push('One or more requirements are empty')
  }

  if (smFile.integrationPoints.some(point => !point.trim())) {
    issues.push('One or more integration points are empty')
  }

  // Check for potentially problematic content
  if (smFile.name.includes('\n')) {
    issues.push('Feature name contains newlines')
  }

  if (smFile.architecture.includes('```')) {
    issues.push('Architecture contains code block markers (``` will be added automatically)')
  }

  return {
    valid: issues.length === 0,
    issues
  }
}